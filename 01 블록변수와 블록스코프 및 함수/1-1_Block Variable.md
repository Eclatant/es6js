#CH 1. 블록변수와 블록스코프 및 함수

## 1-1. 블록변수

### 1-1-1. 기존 변수 var의 문제점 : 함수 스코프 지향 변수
기존 var 변수가 함수 안에 선언 되었을 경우에는 var  변수는 함수 내부 어디에서도 접근이 가능하다.
이는 문(statement) 내부에서도 선언된 변수 역시 마찬가지다.

```js
var a = 1; //전역변수로 어디든 접근 가능, global scope

function f(){
	var b = 2;
	console.log(a); //1

	if(true){
		var c = 3;
		console.log(b); //2
	}
	console.log(c); //3 , if문 안에서 선언된 변수임에도 값 접근 가능함
}

f();
```

위와 같이 변수 c는 if문 안에 있음에도 불구하고 함수 f내 어디에서도 변수 c에 접근이 가능하다. 이는 var 변수의 스코프가 함수 블럭이기 때문이다. 그래서 if문 (Statement) 안의 별도의 지역변수를 선언하여 그 해당 블록 안에서만 블록 스코프처럼 보여지도록 사용을 권장해왔다.
 이렇게 javascript의 변수가 다른 언어들과 다른 이유는 변수 설계가 함수 스코프 지향으로 설계 되었기 때문이다. 하지만 ES6 부터는 블록 스코프 지향 변수인 키워드 let이 등장하게 되었다.

### 1-1-2. 기존 변수 var의 문제점 : 변수의 재선언
var로 선언된 변수와 let 으로 선언된 변수의 차이를 보자.

```js
/* var 변수의 재선언 */
var a = 10;
console.log(a); //10

var a = 12;
console.log(a); //12
```

```js
/* let 변수의 재선언 */
let a = 10;
console.log(a);

let a = 12;
console.log(a);
//Identifier 'a' has already been declared
```
var로 선언한 변수를 재선언 시에는 오류가 없으나, let으로 선언된 변수의 경우에는 이미 'b' 변수를 선언했기 때문에 오류가 발생한다. let으로 선언한 변수의 값을 바꾸기 위해서는 아래와 같이 값을 바꿀 수 있다.

```js
let a = 10;
console.log(a); //10

a = 12;
console.log(a); //12
```

### 1-1-3. 호이스팅
var 변수의 큰 특징은 함수 스코프 지향과 변수의 재선언 시 문제가 되지 않는다는 점이다. 이로 인해 javascript를 학습 할 때 '호이스팅'의 개념을 이해했어야만 했다.

**호이스팅이란?**
'Hoisting'은 '끌어올리다'라는 사전적 의미와 같이 함수 내 어느 위치에서 변수를 선언하더라도 함수의 최상단으로 변수가 선언되는 것을 뜻한다. 이러한 특징은 함수 스코프 지향의 변수 선언과도 연관이 있다.
